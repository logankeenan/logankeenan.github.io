<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description"
          content="Rendering Handlebar Templates with Rust and Wasm">
    <link rel="stylesheet" href="../styles/highlight-js-a11y-dark.css">
    <link rel="stylesheet" href="../styles-v6.css"/>
    <title>Logan Keenan - Rendering Handlebar Templates with Rust and Wasm</title>
</head>
<body>
<nav class="main-nav">
    <a href="/">Home</a>
    <a target="_blank" href="https://cultivatedsoftware.com">Hire Me</a>
    <a href="../talks.html">Talks</a>
</nav>
<section>
    <h1>Rendering Handlebar Templates with Rust and Wasm (Web Assembly)</h1>
    <time datetime="2020-06-24">
        June 24, 2020
    </time>
    <p>
        The Rust implementation of <a target="_blank" href="https://github.com/sunng87/handlebars-rust">Handlebars</a>
        was easy to use on a server, so I wanted
        to see what it would take to render templates in the browser. I'm going to demonstration two features for
        Handlebars. However, it's not limited to these. Lets take a look at using partials and helpers.
    </p>
    <h2>
        Handlebar Partials
    </h2>
    <p>
        We'll leverage partials to create a page layout and nest a page within it.
        The code was basically the same as the server. However, the templates cannot be read from
        the file system in the browser. Thankfully, Rust has the <a target="_blank"
                                                     href="https://doc.rust-lang.org/std/macro.include_str.html">include_str!</a>
        macro which allows the templates to be read at compile time and included in the binary.
    </p>
    <pre><code class="handlebars">&lt;section&gt;
    &lt;h1&gt;Plantings 2020&lt;/h1&gt;
    {{&gt; page_content}}
&lt;/section&gt;
</code></pre>
    <pre><code class="handlebars">{{#&gt; layout_page}}
    {{#*inline &quot;page_content&quot;}}
        &lt;ul&gt;
            {{#each plants}}
                &lt;li&gt;
                    {{this}}
                &lt;/li&gt;
            {{/each}}
        &lt;/ul&gt;
    {{/inline}}
{{/layout_page}}
</code></pre>
    <pre><code class="rust">let layout = include_str!("./templates/layout.hbs");
let plantings_2020 = include_str!("templates/plantings_list.hbs");

let mut handlebars = Handlebars::new();
handlebars.register_template_string("layout_page", layout).unwrap();
let result = handlebars.render_template(
    plantings_2020,
    &json!({"plants":["green beans","tomatoes","peas","zucchini","peppers","cucumbers","soy beans","corn","melons"]}),
);
</code></pre>
    <h2>Handlebar Helpers</h2>
    <p>Fortunately, custom helpers is the same as on the server.</p>
    <pre><code class="rust">handlebars_helper!(uppercase: | string_to_uppercase: str| {
    string_to_uppercase.to_uppercase()
});
handlebars.register_helper("uppercase", Box::new(uppercase));
</code></pre>

    <h2>Next Steps</h2>
    <p>
        Check out the demo <a href="https://github.com/logankeenan/logankeenan.github.io/repos/wasm-handlebars">repository</a>
        to see the full code as well as a working <a href="https://logankeenan.com/repos/wasm-handlebars/index.html">demo</a>.
        The demo simply calls the Rust code (compiled to Wasm) which returns some html markup which is set to the
        document body.
    </p>
    <p>
        This solution doesn't seem all that developer friendly. Developers would have to remember to include any new template
        so they'll be contained in the binary. The <a target="_blank" href="https://crates.io/crates/include_dir">include_dir</a>
        crate could allow for the creation of a template factory using path with filename as a parameter for a given template.
    </p>
</section>
<script src="../scripts/highlight-handlebars-rust.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>